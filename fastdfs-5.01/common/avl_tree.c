#include "avl_tree.h"

/* 初始化AVL子树 */
int avl_tree_init(AVLTreeInfo *tree, FreeDataFunc free_data_func, \
	CompareFunc compare_func)
{
	tree->root = NULL;
	tree->free_data_func = free_data_func;
	tree->compare_func = compare_func;
	return 0;
}

/* 递归销毁所有平衡二叉树节点占用空间 */
static void avl_tree_destroy_loop(FreeDataFunc free_data_func, \
		AVLTreeNode *pCurrentNode)
{
	if (pCurrentNode->left != NULL)
	{
		avl_tree_destroy_loop(free_data_func, pCurrentNode->left);
	}
	if (pCurrentNode->right != NULL)
	{
		avl_tree_destroy_loop(free_data_func, pCurrentNode->right);
	}
	
	if (free_data_func != NULL)
	{
		free_data_func(pCurrentNode->data);
	}
	free(pCurrentNode);
}

/* 递归销毁平衡二叉树 */
void avl_tree_destroy(AVLTreeInfo *tree)
{
	if (tree == NULL)
	{
		return;
	}

	if (tree->root != NULL)
	{
		avl_tree_destroy_loop(tree->free_data_func, tree->root);
		tree->root = NULL;
	}
}

/* 创建一个二叉树节点，返回其指针 */
static AVLTreeNode *createTreeNode(AVLTreeNode *pParentNode, void *target_data)
{
	AVLTreeNode *pNewNode;
	pNewNode = (AVLTreeNode *)malloc(sizeof(AVLTreeNode));
	if (pNewNode == NULL)
	{
		/*
		fprintf(stderr, "file: "__FILE__", line: %d, " \
			"malloc %d bytes fail!\n", __LINE__, \
			(int)sizeof(AVLTreeNode));
		*/
		return NULL;
	}

	pNewNode->left = pNewNode->right = NULL;
	pNewNode->data = target_data;
	pNewNode->balance = 0;

	return pNewNode;
}

/* 左旋调整 */
static void avlRotateLeft(AVLTreeNode *pRotateNode, AVLTreeNode **ppRaiseNode)
{
	*ppRaiseNode = pRotateNode->right;
	pRotateNode->right = (*ppRaiseNode)->left;
	(*ppRaiseNode)->left = pRotateNode;
}

/* 右旋调整 */
static void avlRotateRight(AVLTreeNode *pRotateNode, AVLTreeNode **ppRaiseNode)
{
	*ppRaiseNode = pRotateNode->left;
	pRotateNode->left = (*ppRaiseNode)->right;
	(*ppRaiseNode)->right = pRotateNode;
}

/* 左子树增加节点，调整至平衡 */
static void avlLeftBalanceWhenInsert(AVLTreeNode **pTreeNode, int *taller)
{
	AVLTreeNode *leftsub;
	AVLTreeNode *rightsub;

	leftsub = (*pTreeNode)->left;
	switch (leftsub->balance)
	{
		/* 左子树的外边插入，右旋操作 */
		case -1 :
			(*pTreeNode)->balance = leftsub->balance = 0;
			/* 右旋调整 */
			avlRotateRight (*pTreeNode, pTreeNode); 
			*taller = 0;
			break;
		case 0 :
			break;
		/* 
		 * 左子树的内边插入，先左旋，再右旋
		 * 再根据左子树的右子树的平衡因子来修改不平衡节点及其左子树的平衡因子
		 */
		case 1 :
			rightsub = leftsub->right;
			switch ( rightsub->balance )
			{
				case -1:
					(*pTreeNode)->balance = 1;
					leftsub->balance = 0;
					break;
				case 0 :
					(*pTreeNode)->balance = leftsub->balance = 0;
					break;
				case 1 :
					(*pTreeNode)->balance = 0;
					leftsub->balance = -1;
					break;
			}

			rightsub->balance = 0;
			avlRotateLeft( leftsub, &((*pTreeNode)->left));
			avlRotateRight(*pTreeNode, pTreeNode);
			*taller = 0;
	}
}

/* 右子树增加节点，调整至平衡 */
static void avlRightBalanceWhenInsert(AVLTreeNode **pTreeNode, int *taller)
{
	AVLTreeNode *rightsub;
	AVLTreeNode *leftsub;

	rightsub = (*pTreeNode)->right;
	switch (rightsub->balance)
	{
		/* 右子树的外边插入，左旋操作 */
		case 1: 
			(*pTreeNode)->balance = rightsub->balance = 0;
			avlRotateLeft(*pTreeNode, pTreeNode);
			*taller = 0;
			break;
		case 0: 
			break; 
		/* 
		 * 右子树的内边插入，先右旋，再左旋
		 * 再根据右子树的左子树的平衡因子来修改不平衡节点及其右子树的平衡因子
		 */
		case -1:
			leftsub = rightsub->left;
			switch (leftsub->balance)
			{ 
				case 1 :
					(*pTreeNode)->balance = -1;
					rightsub->balance = 0;
					break;
				case 0 :
					(*pTreeNode)->balance = rightsub->balance = 0;
					break;
				case -1 :
					(*pTreeNode)->balance = 0;
					rightsub->balance = 1;
					break;
			}

			leftsub->balance = 0;
			avlRotateRight(rightsub, &((*pTreeNode)->right));
			avlRotateLeft(*pTreeNode, pTreeNode);
			*taller = 0;
	}
}

/* 递归向平衡二叉树某个子树中插入某个值 */
static int avl_tree_insert_loop(CompareFunc compare_func, AVLTreeNode **pCurrentNode, \
		void *target_data, int *taller)
{
	int nCompRes;
	int success;

	if (*pCurrentNode == NULL)
	{
		/* 创建一个二叉树节点，返回其指针 */
		*pCurrentNode = createTreeNode(*pCurrentNode, target_data);
		if (*pCurrentNode != NULL)
		{
			/* taller如果没有到不平衡的节点，值为1 ，后面不平衡节点处理完之后置为0 */
			*taller = 1;
			return 1;
		}
		else
		{
			return -ENOMEM;
		}
	}

	nCompRes = compare_func((*pCurrentNode)->data, target_data);
	/* 如果当前节点比要插入的节点值大，递归插入左子树 */
	if (nCompRes > 0)
	{
		success = avl_tree_insert_loop(compare_func, \
				&((*pCurrentNode)->left), target_data, taller);
		/* 如果还没到第一个不平衡的节点 */
		if (*taller != 0)
		{
			/* 根据当前节点的平衡因子来决定是否旋转 */
			switch ((*pCurrentNode)->balance)
			{
				case -1:
					/* 找到第一个不平衡的节点，需要调整 */
					avlLeftBalanceWhenInsert(pCurrentNode, taller);
					break;
				case 0:
					/* 当前节点平衡，继续回溯上一个节点 */
					(*pCurrentNode)->balance = -1;
					break;
				case 1:
					/* 左子树中插入节点以后没有导致不平衡，taller=0，不再需要调整 */
					(*pCurrentNode)->balance = 0;
					*taller = 0;
					break;
			}
		}
	}
	/* 如果当前节点比要插入的节点值小，递归插入右子树 */
	else if (nCompRes < 0)
	{
		success = avl_tree_insert_loop(compare_func, \
				&((*pCurrentNode)->right), target_data, taller);
		if (*taller != 0)
		{
			/* 根据当前节点的平衡因子来决定是否旋转 */
			switch ((*pCurrentNode)->balance)
			{
				/* 找到第一个不平衡的节点，需要调整 */
				case -1: 
					(*pCurrentNode)->balance = 0;
					*taller = 0;
					break;
				case 0:
					(*pCurrentNode)->balance = 1; 
					break;
				case 1:
					avlRightBalanceWhenInsert(pCurrentNode, taller);
					break;
			}
		}
	}
	else
	{
		return 0;
	}

	return success;
}

/* 向平衡二叉树中插入一个数据 */
int avl_tree_insert(AVLTreeInfo *tree, void *data)
{
	int taller;

	taller = 0;
	return avl_tree_insert_loop(tree->compare_func, &(tree->root), \
				data, &taller);
}

static int avl_tree_replace_loop(CompareFunc compare_func, \
		FreeDataFunc free_data_func, AVLTreeNode **pCurrentNode, \
		void *target_data, int *taller)
{
	int nCompRes;
	int success;

	if (*pCurrentNode == NULL )
	{
		*pCurrentNode = createTreeNode(*pCurrentNode, target_data);
		if (*pCurrentNode != NULL)
		{
			*taller = 1;
			return 1;
		}
		else
		{
			return -ENOMEM;
		}
	}

	nCompRes = compare_func((*pCurrentNode)->data, target_data);
	if (nCompRes > 0)
	{
		success = avl_tree_replace_loop(compare_func, free_data_func, 
				&((*pCurrentNode)->left), target_data, taller);
		if (*taller != 0)
		{
			switch ((*pCurrentNode)->balance)
			{
				case -1:
					avlLeftBalanceWhenInsert(pCurrentNode, taller);
					break;
				case 0:
					(*pCurrentNode)->balance = -1;
					break;
				case 1:
					(*pCurrentNode)->balance = 0;
					*taller = 0;
					break;
			}
		}
	}
	else if (nCompRes < 0)
	{
		success = avl_tree_replace_loop(compare_func, free_data_func, 
				&((*pCurrentNode)->right), target_data, taller);
		if (*taller != 0) 
		{
			switch ((*pCurrentNode)->balance)
			{
				case -1 : 
					(*pCurrentNode)->balance = 0;
					*taller = 0;
					break;
				case 0 :
					(*pCurrentNode)->balance = 1; 
					break;
				case 1 :
					avlRightBalanceWhenInsert(pCurrentNode, taller);
					break;
			}
		}
	}
	else
	{
		if (free_data_func != NULL)
		{
			free_data_func((*pCurrentNode)->data);
		}
		(*pCurrentNode)->data = target_data;
		return 0;
	}

	return success;
}

int avl_tree_replace(AVLTreeInfo *tree, void *data)
{
	int taller;

	taller = 0;
	return avl_tree_replace_loop(tree->compare_func, \
			tree->free_data_func, &(tree->root), data, &taller);
}

/* 
 * 递归在AVL树中查找某个节点 
 * 若有相等的节点，返回对应节点指针，否则返回NULL
 */
static AVLTreeNode *avl_tree_find_loop(CompareFunc compare_func, \
		AVLTreeNode *pCurrentNode, void *target_data)
{
	int nCompRes;
	nCompRes = compare_func(pCurrentNode->data, target_data);
	if (nCompRes > 0)
	{
		if (pCurrentNode->left == NULL)
		{
			return NULL;
		}
		else
		{
			return avl_tree_find_loop(compare_func, \
				pCurrentNode->left, target_data);
		}
	}
	else if (nCompRes < 0)
	{
		if (pCurrentNode->right == NULL)
		{
			return NULL;
		}
		else
		{
			return avl_tree_find_loop(compare_func, \
				pCurrentNode->right, target_data);
		}
	}
	else
	{
		return pCurrentNode;
	}
}

/* 
 * 递归查找和target_data一样的值，如果没有，就返回第一个稍大一些的值 
 */
static void *avl_tree_find_ge_loop(CompareFunc compare_func, \
		AVLTreeNode *pCurrentNode, void *target_data)
{
	int nCompRes;
	void *found;

	nCompRes = compare_func(pCurrentNode->data, target_data);
	if (nCompRes > 0)
	{
		if (pCurrentNode->left == NULL)
		{
			return pCurrentNode->data;
		}

		found = avl_tree_find_ge_loop(compare_func, \
				pCurrentNode->left, target_data);
		return found != NULL ? found : pCurrentNode->data;
	}
	else if (nCompRes < 0)
	{
		if (pCurrentNode->right == NULL)
		{
			return NULL;
		}
		else
		{
			return avl_tree_find_ge_loop(compare_func, \
				pCurrentNode->right, target_data);
		}
	}
	else
	{
		return pCurrentNode->data;
	}
}

/* 在AVL树中查找某个节点 */
void *avl_tree_find(AVLTreeInfo *tree, void *target_data)
{
	AVLTreeNode *found;

	if (tree->root == NULL)
	{
		return NULL;
	}

	found = avl_tree_find_loop(tree->compare_func, \
			tree->root, target_data);

	return found != NULL ? found->data : NULL;
}

/* 递归查找和target_data一样的值，如果没有，就返回第一个稍大一些的值 */
void *avl_tree_find_ge(AVLTreeInfo *tree, void *target_data)
{
	void *found;

	if (tree->root == NULL)
	{
		found = NULL;
	}
	else
	{
		found = avl_tree_find_ge_loop(tree->compare_func, \
			tree->root, target_data);
	}

	return found;
}

/* 右子树减去节点，调整至平衡 */
static void avlLeftBalanceWhenDelete(AVLTreeNode **pTreeNode, int *shorter)
{
	AVLTreeNode *leftsub;
	AVLTreeNode *rightsub;

	leftsub = (*pTreeNode)->left;
	switch (leftsub->balance)
	{
		case -1:
			(*pTreeNode)->balance = leftsub->balance = 0;
			avlRotateRight (*pTreeNode, pTreeNode);
			break;
		case 0:
			leftsub->balance = 1;
			avlRotateRight(*pTreeNode, pTreeNode);
			*shorter = 0;
			break;
		case 1:
			rightsub = leftsub->right;
			switch ( rightsub->balance )
			{
				case -1:
					(*pTreeNode)->balance = 1;
					leftsub->balance = 0;
					break;
				case 0 :
					(*pTreeNode)->balance = leftsub->balance = 0;
					break;
				case 1 :
					(*pTreeNode)->balance = 0;
					leftsub->balance = -1;
					break;
			}

			rightsub->balance = 0;
			avlRotateLeft( leftsub, &((*pTreeNode)->left));
			avlRotateRight(*pTreeNode, pTreeNode);
			break;
	}
}

/* 左子树减去节点，调整至平衡 */
static void avlRightBalanceWhenDelete(AVLTreeNode **pTreeNode, int *shorter)
{
	AVLTreeNode *rightsub;
	AVLTreeNode *leftsub;

	rightsub = (*pTreeNode)->right;
	switch (rightsub->balance)
	{
		/* 不平衡节点的右子树平衡因子为1 ，左旋一次*/
		case 1:
			(*pTreeNode)->balance = rightsub->balance = 0;
			avlRotateLeft(*pTreeNode, pTreeNode);
			break;
		/* 左旋一次，但是因为深度和原来比没变，所以不需要再往上回溯，*shorter = 0 */
		case 0:
			rightsub->balance = -1;
			avlRotateLeft(*pTreeNode, pTreeNode);
			*shorter = 0;
			break;
		/* 先右旋再左旋，根据不平衡节点的右子树的左子树的平衡因子来修改其他节点的平衡因子 */
		case -1:
			leftsub = rightsub->left;
			switch (leftsub->balance)
			{
				case 1:
					(*pTreeNode)->balance = -1;
					rightsub->balance = 0;
					break;
				case 0:
					(*pTreeNode)->balance = rightsub->balance = 0;
					break;
				case -1:
					(*pTreeNode)->balance = 0;
					rightsub->balance = 1;
					break;
			}

			leftsub->balance = 0;
			avlRotateRight(rightsub, &((*pTreeNode)->right));
			avlRotateLeft(*pTreeNode, pTreeNode);
			break;
	}
}

/* 递归删除指定的data值的节点，如果pDeletedDataNode不为空，返回删除节点的信息 */
static int avl_tree_delete_loop(AVLTreeInfo *tree, AVLTreeNode **pCurrentNode,\
		 void *target_data, int *shorter, AVLTreeNode *pDeletedDataNode)
{
	int nCompRes;
	bool result;
	AVLTreeNode *leftsub;
	AVLTreeNode *rightsub;

	/* 如果pDeletedDataNode不为空，说明需要找到左子树中最大的元素与之替换 */
	if (pDeletedDataNode != NULL)
	{
		/* 如果需要返回删除节点信息并且右子树为空，删除当前节点 */
		if ((*pCurrentNode)->right == NULL)
		{
			pDeletedDataNode->data = (*pCurrentNode)->data;
			leftsub = (*pCurrentNode)->left;

			free(*pCurrentNode);
			*pCurrentNode = leftsub;
			*shorter = 1;
			return 1;
		}

		/* 否则说明要删除节点值比当前节点大，继续递归在右子树中删除 */
		nCompRes = -1;
	}
	else
	{
		nCompRes = tree->compare_func((*pCurrentNode)->data, target_data);
	}

	/* 要删除的节点在左子树 */
	if (nCompRes > 0)
	{
		/* 左子树为空，未找到需要删除的节点 */
		if ((*pCurrentNode)->left == NULL)
		{
			return 0;
		}

		/* 递归在左子树中继续删除 */
		result = avl_tree_delete_loop(tree, &((*pCurrentNode)->left), \
				target_data, shorter, pDeletedDataNode);
		if (*shorter != 0)
		{
			switch ((*pCurrentNode)->balance)
			{
			  case -1:
			  	/* 当前节点平衡了，但是父节点可能仍然不平衡，shorter仍然为1 */
				(*pCurrentNode)->balance = 0;
				break;
			  case 0:
			  	/* 到此节点已经完成调整 */
				(*pCurrentNode)->balance = 1;
				*shorter = 0;
				break;
			  case 1:
				avlRightBalanceWhenDelete(pCurrentNode, shorter);
				break;
			}
		}
		return result;
	}
	/* 要删除的节点在右子树 */
	else if (nCompRes < 0)
	{
		if ((*pCurrentNode)->right == NULL)
		{
			return 0;
		}

		result = avl_tree_delete_loop(tree, &((*pCurrentNode)->right), \
				target_data, shorter, pDeletedDataNode);
		if (*shorter != 0)
		{
			switch ((*pCurrentNode)->balance)
			{
				case -1:
		          		avlLeftBalanceWhenDelete(pCurrentNode, shorter);
		          		break;
		        	case 0:
		          		(*pCurrentNode)->balance = -1;
				  	*shorter = 0;
		          		break;
		        	case 1:
		  	        	(*pCurrentNode)->balance = 0;
		        	  	break;
		    	}
		}
		return result;
	}
	/* data值相等，找到了要删除的节点 */
	else
	{
		/* 释放data的内存空间 */
		if (tree->free_data_func != NULL)
		{
			tree->free_data_func((*pCurrentNode)->data);
		}

		leftsub = (*pCurrentNode)->left;
		rightsub = (*pCurrentNode)->right;
		/* 只有右子树，父节点指向右子树 */
		if (leftsub == NULL)
		{
			free(*pCurrentNode);
			*pCurrentNode = rightsub;
		}
		/* 只有左子树，父节点指向左子树 */
		else if (rightsub == NULL)
		{
			free(*pCurrentNode);
			*pCurrentNode = leftsub;
		}
		else
		{
			/* 找到左子树中最大的节点，将值赋值给当前节点的data，删除那个节点 */
			avl_tree_delete_loop(tree, &((*pCurrentNode)->left), \
				target_data, shorter, *pCurrentNode);

			if (*shorter != 0)
			{
				switch ((*pCurrentNode)->balance)
				{
				  case -1:
					(*pCurrentNode)->balance = 0;
					break;
				  case 0:
					(*pCurrentNode)->balance = 1;
					*shorter = 0;
					break;
				  case 1:
					avlRightBalanceWhenDelete(pCurrentNode, shorter);
					break;
				}
			}
			return 1;
		}

		*shorter = 1;
		return 1;
	}
}

/* 在AVL树中删除一个节点 */
int avl_tree_delete(AVLTreeInfo *tree, void *data)
{
	int shorter;

	if (tree->root == NULL)
	{
		return 0;
	}

	shorter = 0;
	return avl_tree_delete_loop(tree, &(tree->root), data, &shorter, NULL);
}

/* 中序遍历avl树的每一个节点，执行data_op_func回调函数 */
static int avl_tree_walk_loop(DataOpFunc data_op_func, \
		AVLTreeNode *pCurrentNode, void *args)
{
	int result;

	if (pCurrentNode->left != NULL)
	{
		result = avl_tree_walk_loop(data_op_func, \
				pCurrentNode->left, args);
		if (result != 0)
		{
			return result;
		}
	}

	if ((result=data_op_func(pCurrentNode->data, args)) != 0)
	{
		return result;
	}

	/*
	if (pCurrentNode->balance >= -1 && pCurrentNode->balance <= 1)
	{
		//printf("==%d\n", pCurrentNode->balance);
	}
	else
	{
		printf("==bad %d!!!!!!!!!!!!\n", pCurrentNode->balance);
	}
	*/

	if (pCurrentNode->right != NULL)
	{
		result = avl_tree_walk_loop(data_op_func, \
				pCurrentNode->right, args);
	}

	return result;
}

/* 中序遍历avl树的每一个节点，执行data_op_func回调函数 */
int avl_tree_walk(AVLTreeInfo *tree, DataOpFunc data_op_func, void *args)
{
	if (tree->root == NULL)
	{
		return 0;
	}
	else
	{
		return avl_tree_walk_loop(data_op_func, tree->root, args);
	}
}

/* 递归计算AVL树的节点个数 */
static void avl_tree_count_loop(AVLTreeNode *pCurrentNode, int *count)
{
	if (pCurrentNode->left != NULL)
	{
		avl_tree_count_loop(pCurrentNode->left, count);
	}

	(*count)++;

	if (pCurrentNode->right != NULL)
	{
		avl_tree_count_loop(pCurrentNode->right, count);
	}
}

/* 返回AVL树的节点个数 */
int avl_tree_count(AVLTreeInfo *tree)
{
	int count;
	if (tree->root == NULL)
	{
		return 0;
	}

	count = 0;
	avl_tree_count_loop(tree->root, &count);
	return count;
}

/*计算AVL树的深度 */
int avl_tree_depth(AVLTreeInfo *tree)
{
	int depth;
	AVLTreeNode *pNode;

	if (tree->root == NULL)
	{
		return 0;
	}

	depth = 0;
	pNode = tree->root;
	while (pNode != NULL)
	{
		if (pNode->balance == -1)
		{
			pNode = pNode->left;
		}
		else
		{
			pNode = pNode->right;
		}
		depth++;
	}

	return depth;
}

/*
static void avl_tree_print_loop(AVLTreeNode *pCurrentNode)
{
	printf("%ld  left: %ld, right: %ld, balance: %d\n", pCurrentNode->data, 
		pCurrentNode->left != NULL ? pCurrentNode->left->data : 0,
		pCurrentNode->right != NULL ? pCurrentNode->right->data : 0,
		pCurrentNode->balance);

	if (pCurrentNode->left != NULL)
	{
		avl_tree_print_loop(pCurrentNode->left);
	}

	if (pCurrentNode->right != NULL)
	{
		avl_tree_print_loop(pCurrentNode->right);
	}
}

void avl_tree_print(AVLTreeInfo *tree)
{
	if (tree->root == NULL)
	{
		return;
	}

	avl_tree_print_loop(tree->root);
}
*/

