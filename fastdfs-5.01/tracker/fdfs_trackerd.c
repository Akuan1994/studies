/**
* Copyright (C) 2008 Happy Fish / YuQing
*
* FastDFS may be copied only under the terms of the GNU General
* Public License V3, which may be found in the FastDFS source kit.
* Please visit the FastDFS Home Page http://www.csource.org/ for more detail.
**/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include "shared_func.h"
#include "pthread_func.h"
#include "process_ctrl.h"
#include "logger.h"
#include "fdfs_global.h"
#include "base64.h"
#include "sockopt.h"
#include "sched_thread.h"
#include "tracker_types.h"
#include "tracker_mem.h"
#include "tracker_service.h"
#include "tracker_global.h"
#include "tracker_proto.h"
#include "tracker_func.h"
#include "tracker_status.h"
#include "tracker_relationship.h"

#ifdef WITH_HTTPD
#include "tracker_httpd.h"
#include "tracker_http_check.h"
#endif

#if defined(DEBUG_FLAG)

/*
#if defined(OS_LINUX)
#include "linux_stack_trace.h"
static bool bSegmentFault = false;
#endif
*/

#include "tracker_dump.h"
#endif

static bool bTerminateFlag = false;		/* 是否正在终止 */
static bool bAcceptEndFlag = false;		/* 是否停止accept的标志 */

static char bind_addr[IP_ADDRESS_SIZE];	/* 绑定IP地址 */

static void sigQuitHandler(int sig);		/* 退出信号处理*/
static void sigHupHandler(int sig);
static void sigUsrHandler(int sig);		/* 忽略信号处理 */
static void sigAlarmHandler(int sig);

#if defined(DEBUG_FLAG)
/*
#if defined(OS_LINUX)
static void sigSegvHandler(int signum, siginfo_t *info, void *ptr);
#endif
*/

static void sigDumpHandler(int sig);
#endif

#define SCHEDULE_ENTRIES_COUNT 4		/* 定时任务链表初始节点数 */

static void usage(const char *program)
{
	fprintf(stderr, "Usage: %s <config_file> [start | stop | restart]\n",
		program);
}

int main(int argc, char *argv[])
{
	char *conf_filename;		/* 配置文件路径 */
	int result;
	int wait_count;
	int sock;
	pthread_t schedule_tid;		/* 定时任务线程tid */
	struct sigaction act;
	ScheduleEntry scheduleEntries[SCHEDULE_ENTRIES_COUNT];	/* 定时任务链表对应的数组 */
	ScheduleArray scheduleArray;		/* 定时任务链表 */
	char pidFilename[MAX_PATH_SIZE];		/* 进程号文件名 */
	bool stop;							/* 是否停止tracker守护进程 */

	if (argc < 2)
	{
		usage(argv[0]);
		return 1;
	}

	g_current_time = time(NULL);
	g_up_time = g_current_time;		/* 设置进程启动时间 */
	srand(g_up_time);	/* 设置随机数种子 */

	/* 初始化日志对象 */
	log_init();

	conf_filename = argv[1];	/* tracker服务器配置文件名 */
	/* 加载tracker配置文件到内存中并且获取配置文件中的"base_path"字段值 */
	if ((result=get_base_path_from_conf_file(conf_filename,
		g_fdfs_base_path, sizeof(g_fdfs_base_path))) != 0)
	{
		log_destroy();
		return result;
	}

	printf("wcl: base_path: %s\n", g_fdfs_base_path);

	/* 设置pid文件路径 */
	snprintf(pidFilename, sizeof(pidFilename),
		"%s/data/fdfs_trackerd.pid", g_fdfs_base_path);
	/* 处理启动参数，start | restart | stop */
	if ((result=process_action(pidFilename, argv[2], &stop)) != 0)
	{
		if (result == EINVAL)
		{
			usage(argv[0]);
		}
		log_destroy();
		return result;
	}
	/* 
	 * 如果启动参数是stop，这里退出
	 * 如果是start或者是restart，后面会根据配置文件参数启动守护进程
	 */
	if (stop)
	{
		log_destroy();
		return 0;
	}

#if defined(DEBUG_FLAG) && defined(OS_LINUX)
	if (getExeAbsoluteFilename(argv[0], g_exe_name, \
		sizeof(g_exe_name)) == NULL)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return errno != 0 ? errno : ENOENT;
	}
#endif

	memset(bind_addr, 0, sizeof(bind_addr));
	/* 加载tracker服务器配置文件，设置相应变量，返回绑定ip地址 */
	if ((result=tracker_load_from_conf_file(conf_filename, \
			bind_addr, sizeof(bind_addr))) != 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}

	/* 从文件中获取tracker server的状态信息 */
	if ((result=tracker_load_status_from_file(&g_tracker_last_status)) != 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}

	base64_init_ex(&g_base64_context, 0, '-', '_', '.');

	/* 根据当前时间设置随机数种子 */
	if ((result=set_rand_seed()) != 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"set_rand_seed fail, program exit!", __LINE__);
		return result;
	}

	/* tracker server数据加载到内存中 */
	if ((result=tracker_mem_init()) != 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}

	/* 创建socket 服务端 */
	sock = socketServer(bind_addr, g_server_port, &result);
	if (sock < 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}

	/* 设置socket服务端相关参数 */
	if ((result=tcpsetserveropt(sock, g_fdfs_network_timeout)) != 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}

	/* 创建守护进程 */
	daemon_init(true);
	umask(0);

	/* 将tracker守护进程的进程号写入到pid文件中 */
	if ((result=write_to_pid_file(pidFilename)) != 0)
	{
		log_destroy();
		return result;
	}

	/* 将log文件描述符dup到标准输出或错误输出*/
	if (dup2(g_log_context.log_fd, STDOUT_FILENO) < 0 || \
		dup2(g_log_context.log_fd, STDERR_FILENO) < 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"call dup2 fail, errno: %d, error info: %s, " \
			"program exit!", __LINE__, errno, STRERROR(errno));
		g_continue_flag = false;
		return errno;
	}

	/* tracker服务的初始化 */
	if ((result=tracker_service_init()) != 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}
	
	memset(&act, 0, sizeof(act));
	sigemptyset(&act.sa_mask);

	/* 指定SIGUSR1和SIGUSR2信号的处理函数为sigUsrHandler(忽略信号) */
	act.sa_handler = sigUsrHandler;
	if(sigaction(SIGUSR1, &act, NULL) < 0 || \
		sigaction(SIGUSR2, &act, NULL) < 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"call sigaction fail, errno: %d, error info: %s", \
			__LINE__, errno, STRERROR(errno));
		logCrit("exit abnormally!\n");
		return errno;
	}

	/* 指定SIGHUP信号的处理函数为sigHupHandler(立即轮转日志) */
	act.sa_handler = sigHupHandler;
	if(sigaction(SIGHUP, &act, NULL) < 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"call sigaction fail, errno: %d, error info: %s", \
			__LINE__, errno, STRERROR(errno));
		logCrit("exit abnormally!\n");
		return errno;
	}

	/* 指定忽略SIGPIPE信号 */
	act.sa_handler = SIG_IGN;
	if(sigaction(SIGPIPE, &act, NULL) < 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"call sigaction fail, errno: %d, error info: %s", \
			__LINE__, errno, STRERROR(errno));
		logCrit("exit abnormally!\n");
		return errno;
	}

	/* 指定SIGINT,SIGTERM,SIGQUIT的信号处理函数为sigQuitHandler(不断向自己发送退出报文) */
	act.sa_handler = sigQuitHandler;
	if(sigaction(SIGINT, &act, NULL) < 0 || \
		sigaction(SIGTERM, &act, NULL) < 0 || \
		sigaction(SIGQUIT, &act, NULL) < 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"call sigaction fail, errno: %d, error info: %s", \
			__LINE__, errno, STRERROR(errno));
		logCrit("exit abnormally!\n");
		return errno;
	}

#if defined(DEBUG_FLAG)
/*
#if defined(OS_LINUX)
	memset(&act, 0, sizeof(act));
	sigemptyset(&act.sa_mask);
        act.sa_sigaction = sigSegvHandler;
        act.sa_flags = SA_SIGINFO;
        if (sigaction(SIGSEGV, &act, NULL) < 0 || \
        	sigaction(SIGABRT, &act, NULL) < 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"call sigaction fail, errno: %d, error info: %s", \
			__LINE__, errno, STRERROR(errno));
		logCrit("exit abnormally!\n");
		return errno;
	}
#endif
*/

	memset(&act, 0, sizeof(act));
	sigemptyset(&act.sa_mask);
	/* 指定SIGUSR1和SIGUSR2信号的处理函数为sigDumpHandler */
	act.sa_handler = sigDumpHandler;
	if(sigaction(SIGUSR1, &act, NULL) < 0 || \
		sigaction(SIGUSR2, &act, NULL) < 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"call sigaction fail, errno: %d, error info: %s", \
			__LINE__, errno, STRERROR(errno));
		logCrit("exit abnormally!\n");
		return errno;
	}
#endif

#ifdef WITH_HTTPD
	if (!g_http_params.disabled)
	{
		if ((result=tracker_httpd_start(bind_addr)) != 0)
		{
			logCrit("file: "__FILE__", line: %d, " \
				"tracker_httpd_start fail, program exit!", \
				__LINE__);
			return result;
		}

	}

	if ((result=tracker_http_check_start()) != 0)
	{
		logCrit("file: "__FILE__", line: %d, " \
			"tracker_http_check_start fail, " \
			"program exit!", __LINE__);
		return result;
	}
#endif

	/* 设置运行的group_name和username */
	if ((result=set_run_by(g_run_by_group, g_run_by_user)) != 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}

	/* 设置定时任务信息 */
	scheduleArray.entries = scheduleEntries;
	memset(scheduleEntries, 0, sizeof(scheduleEntries));
	
	/* 定时刷新日志缓存到文件中 */
	scheduleEntries[0].id = 1;
	scheduleEntries[0].time_base.hour = TIME_NONE;
	scheduleEntries[0].time_base.minute = TIME_NONE;
	scheduleEntries[0].interval = g_sync_log_buff_interval;
	scheduleEntries[0].task_func = log_sync_func;
	scheduleEntries[0].func_args = &g_log_context;

	/* 定时检测所有的storage的状态是否正常 */
	scheduleEntries[1].id = 2;
	scheduleEntries[1].time_base.hour = TIME_NONE;
	scheduleEntries[1].time_base.minute = TIME_NONE;
	scheduleEntries[1].interval = g_check_active_interval;
	scheduleEntries[1].task_func = tracker_mem_check_alive;
	scheduleEntries[1].func_args = NULL;

	/* 定时将tracker的运行状态信息写入文件 */
	scheduleEntries[2].id = 3;
	scheduleEntries[2].time_base.hour = 0;
	scheduleEntries[2].time_base.minute = 0;
	scheduleEntries[2].interval = TRACKER_SYNC_STATUS_FILE_INTERVAL;
	scheduleEntries[2].task_func = tracker_write_status_to_file;
	scheduleEntries[2].func_args = NULL;

	scheduleArray.count = 3;

	/* 如果设置了每天轮转日志文件，多加一个定时任务 */
	if (g_rotate_error_log)
	{
		/* 定时轮转日志文件 */
		scheduleEntries[scheduleArray.count].id = 4;
		scheduleEntries[scheduleArray.count].time_base = \
				g_error_log_rotate_time;
		scheduleEntries[scheduleArray.count].interval = \
				24 * 3600;
		scheduleEntries[scheduleArray.count].task_func = \
				log_notify_rotate;
		scheduleEntries[scheduleArray.count].func_args = \
				&g_log_context;
		scheduleArray.count++;
	}

	/* 开始运行定时任务调度线程 */
	if ((result=sched_start(&scheduleArray, &schedule_tid, \
		g_thread_stack_size, (bool * volatile)&g_continue_flag)) != 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}

	/* 
	 * 初始化tracker关系维护线程 
	 * 用于检测并设置tracker_leader以及获取所有group的trunk_server_id信息
	 */
	if ((result=tracker_relationship_init()) != 0)
	{
		logCrit("exit abnormally!\n");
		log_destroy();
		return result;
	}

	/* 设置为使用日志缓存 */
	log_set_cache(true);

	bTerminateFlag = false;
	bAcceptEndFlag = false;

	/* 
	 * 循环accept，主进程会阻塞在一个accept中
	 * 如果g_accept_threads>1，会通过多线程来同时accept 
	 */
	tracker_accept_loop(sock);
	bAcceptEndFlag = true;

	/* 结束定时任务调度线程 */
	if (g_schedule_flag)
	{
		pthread_kill(schedule_tid, SIGINT);
	}

	/* 终止所有的工作线程，向每个线程的pipe[1]管道发送小于0的socket描述符 */
	tracker_terminate_threads();

#ifdef WITH_HTTPD
	if (g_http_check_flag)
	{
		tracker_http_check_stop();
	}

	while (g_http_check_flag)
	{
		usleep(50000);
	}
#endif

	/* 
	 * 等待所有的工作线程和定时任务调度线程结束 
	 * 工作线程接收到小于0的sockfd之后，会退出
 	 */
	wait_count = 0;
	while ((g_tracker_thread_count != 0) || g_schedule_flag)
	{
		usleep(10000);
		if (++wait_count > 3000)
		{
			logWarning("waiting timeout, exit!");
			break;
		}
	}

	/* 销毁内存中创建的groups相关的空间及资源 */
	tracker_mem_destroy();

	/* 销毁tracker_service资源 */
	tracker_service_destroy();

	/* 销毁tracker关系维护线程，g_continue_flag置为false，线程会自动结束 */
	tracker_relationship_destroy();
	
	logInfo("exit normally.\n");
	/* 销毁日志相关资源 */
	log_destroy();

	/* 删除pid_file */
	delete_pid_file(pidFilename);
	return 0;
}

#if defined(DEBUG_FLAG)
/*
#if defined(OS_LINUX)
static void sigSegvHandler(int signum, siginfo_t *info, void *ptr)
{
	bSegmentFault = true;

	if (!bTerminateFlag)
	{
		set_timer(1, 1, sigAlarmHandler);

		bTerminateFlag = true;
		g_continue_flag = false;

		logCrit("file: "__FILE__", line: %d, " \
			"catch signal %d, program exiting...", \
			__LINE__, signum);
	
		signal_stack_trace_print(signum, info, ptr);
	}
}
#endif
*/

/* SIGUSR1和SIGUSR2信号的处理函数，将数据dump到文件中 */
static void sigDumpHandler(int sig)
{
	static bool bDumpFlag = false;
	char filename[256];

	/* 如果正在dump中，不进行操作 */
	if (bDumpFlag)
	{
		return;
	}

	bDumpFlag = true;

	snprintf(filename, sizeof(filename), 
		"%s/logs/tracker_dump.log", g_fdfs_base_path);
	/* 将所有配置参数及数据dump到文件中保存 */
	fdfs_dump_tracker_global_vars_to_file(filename);

	bDumpFlag = false;
}

#endif

/* 指定SIGINT,SIGTERM,SIGQUIT的信号处理函数为sigQuitHandler() */
static void sigQuitHandler(int sig)
{
	/* 如果bTerminateFlag为false */
	if (!bTerminateFlag)
	{
		/* 
		 * 设置定时器，延迟first_remain_seconds后，每间隔interval秒，调用sigAlarmHandler函数
		 * 每隔1秒钟，向自己发送退出报文
		 */
		set_timer(1, 1, sigAlarmHandler);

		/* 将bTerminateFlag终止标注改为true */
		bTerminateFlag = true;
		g_continue_flag = false;
		logCrit("file: "__FILE__", line: %d, " \
			"catch signal %d, program exiting...", \
			__LINE__, sig);
	}
}

/* SIGHUP信号的处理函数 */
static void sigHupHandler(int sig)
{
	/* 如果设置了error log日志每天轮转，立即轮转日志 */
	if (g_rotate_error_log)
	{
		g_log_context.rotate_immediately = true;
	}

	logInfo("file: "__FILE__", line: %d, " \
		"catch signal %d, rotate log", __LINE__, sig);
}

/* SIGALRM信号的处理函数 */
static void sigAlarmHandler(int sig)
{
	ConnectionInfo server;

	/* 如果已经接收到了退出报文，直接返回 */
	if (bAcceptEndFlag)
	{
		return;
	}

	logDebug("file: "__FILE__", line: %d, " \
		"signal server to quit...", __LINE__);

	if (*bind_addr != '\0')
	{
		strcpy(server.ip_addr, bind_addr);
	}
	else
	{
		strcpy(server.ip_addr, "127.0.0.1");
	}
	server.port = g_server_port;
	server.sock = -1;

	if (conn_pool_connect_server(&server, g_fdfs_connect_timeout) != 0)
	{
		return;
	}

	/* 向自己发送退出报文 */
	fdfs_quit(&server);
	
	conn_pool_disconnect_server(&server);

	logDebug("file: "__FILE__", line: %d, " \
		"signal server to quit done", __LINE__);
}

/* SIGUSR1和SIGUSR2信号的处理函数 */
static void sigUsrHandler(int sig)
{
	logInfo("file: "__FILE__", line: %d, " \
		"catch signal %d, ignore it", __LINE__, sig);
}

